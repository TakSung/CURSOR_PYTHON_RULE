# Cursor 프롬프트 활용 완전 가이드 - 실전 팁 모음

## 🎯 프롬프팅의 기본 원칙

### 1. 컨텍스트가 왕이다
가장 중요한 원칙은 **충분한 컨텍스트 제공**입니다. AI가 올바른 결정을 내릴 수 있도록 관련 정보를 최대한 많이 제공하세요.

```
❌ 나쁜 예:
"버튼을 만들어줘"

✅ 좋은 예:
"React TypeScript 프로젝트에서 Tailwind CSS를 사용해서 
주요 액션용 파란색 버튼 컴포넌트를 만들어줘. 
hover 효과와 loading 상태도 포함해야 해."
```

### 2. 구체적이고 명확하게
모호한 표현보다는 구체적인 요구사항을 명시하세요.

```
❌ 모호한 예:
"이 코드를 더 좋게 만들어줘"

✅ 구체적인 예:
"이 코드의 성능을 개선하고, TypeScript 타입 안정성을 높이고, 
에러 핸들링을 추가해줘. 특히 API 호출 부분에 재시도 로직도 포함해줘."
```

## 🛠️ Cursor 핵심 기능 활용법

### 1. @ 심볼 활용하기
파일, 폴더, 문서를 참조할 때 `@` 심볼을 적극 활용하세요.

```
// 특정 파일 참조
@components/Button.tsx 를 참고해서 새로운 Input 컴포넌트를 만들어줘

// 폴더 전체 참조 (주의: 컨텍스트 윈도우 한계)
@utils/ 폴더의 함수들을 사용해서 데이터 검증 로직을 작성해줘

// 문서 참조
@docs/api-spec.md 문서를 참고해서 API 클라이언트를 구현해줘
```

### 2. 모드별 활용 전략

#### Agent 모드 (기본 모드, 2025년 권장)
- 파일 생성, 수정, 삭제가 필요한 복합적인 작업에 최적
- 자동으로 여러 파일을 수정하고 테스트까지 실행 가능

```
// Agent 모드에 적합한 프롬프트
"사용자 인증 시스템을 구현해줘. 
- JWT 토큰 기반
- 로그인/회원가입 API 엔드포인트
- 미들웨어로 인증 검사
- 프론트엔드 로그인 폼
- 필요한 테스트 코드도 작성해줘"
```

#### Chat 모드
- 코드 설명, 질문 답변, 디버깅 도움에 적합
- 파일 수정 없이 대화만 필요할 때 사용

```
// Chat 모드에 적합한 프롬프트
"이 에러 메시지가 왜 발생하는지 설명해줘: 
Cannot read property 'map' of undefined"
```

#### Inline Chat (Ctrl/Cmd + K)
- 선택한 코드 블록의 빠른 수정에 최적
- 함수 하나, 컴포넌트 하나 수준의 작업

```
// Inline Chat에 적합한 프롬프트 (코드 선택 후)
"이 함수에 에러 핸들링 추가해줘"
"TypeScript 타입 정의 추가해줘"
"성능 최적화해줘"
```

### 3. 파일 참조 최적화 팁

#### 열린 에디터 참조하기
```
/ 키를 누르고 "Reference Open Editors" 선택
```
현재 열린 모든 탭을 컨텍스트에 추가합니다. 관련 파일들만 열어둔 후 사용하세요.

#### 선택적 파일 추가
불필요한 파일로 컨텍스트를 오염시키지 말고, 정말 필요한 파일만 선택적으로 추가하세요.

```
@components/Header.tsx @styles/globals.css 
이 두 파일을 참고해서 Footer 컴포넌트를 만들어줘
```

## 💡 고급 프롬프팅 기법

### 1. Chain-of-Thought (단계별 사고)
복잡한 작업을 단계별로 나누어 요청하세요.

```
✅ Chain-of-Thought 프롬프트:
"이커머스 제품 목록 페이지를 만들어줘. 다음 순서로 진행해줘:

1. 먼저 제품 데이터 타입 정의
2. API에서 제품 목록 가져오는 hook 작성  
3. 제품 카드 컴포넌트 구현
4. 필터링 기능 추가
5. 페이지네이션 구현
6. 로딩/에러 상태 처리

각 단계마다 설명하고 다음 단계로 넘어가줘."
```

### 2. Few-Shot Learning (예시 제공)
원하는 패턴의 예시를 제공하면 일관된 결과를 얻을 수 있습니다.

```
"다음 패턴으로 API 함수들을 만들어줘:

// 예시
export const getUsers = async (): Promise<User[]> => {
  try {
    const response = await api.get('/users');
    return response.data;
  } catch (error) {
    throw new ApiError('Failed to fetch users', error);
  }
};

이 패턴으로 products, orders, categories API 함수들도 만들어줘."
```

### 3. 테스트 주도 개발 프롬프트
코드 품질을 높이는 강력한 방법입니다.

```
"마크다운을 HTML로 변환하는 함수를 만들어줘. 
다음 순서로 진행해줘:

1. 먼저 테스트 케이스를 작성해줘
2. 그 다음 함수를 구현해줘  
3. 테스트를 실행해서 통과할 때까지 코드를 수정해줘"
```

## 🚀 생산성 극대화 팁

### 1. YOLO 모드 활용
설정에서 YOLO 모드를 켜면 AI가 자동으로 테스트 실행, 빌드 검증까지 해줍니다.

```toml
# YOLO 모드 설정 예시
허용된 명령어: "vitest, npm test, npm run build, tsc, mkdir, touch"
```

### 2. User Rules 설정
전역 설정에서 항상 적용할 룰을 설정하세요.

```
Settings → Rules → User Rules에 추가:

"항상 TypeScript 타입을 명시하고, 
에러 핸들링을 포함하며, 
코드에 간단한 주석을 달아줘. 
고수준의 설명은 하지 말고 구체적인 코드를 제공해줘."
```

### 3. 프로젝트별 .cursorrules 활용
프로젝트 루트에 `.cursorrules` 파일을 만들어 프로젝트별 컨텍스트를 제공하세요.

```
# .cursorrules 예시
이 프로젝트는 Next.js 14 + TypeScript + Tailwind CSS를 사용합니다.

## 기술 스택
- React 18
- Next.js 14 (App Router)
- TypeScript 5.0+
- Tailwind CSS 3.4
- Zustand (상태관리)
- React Query (서버 상태)

## 코딩 규칙
- 모든 컴포넌트는 함수형으로 작성
- Props는 interface로 타입 정의
- 'use client' 지시문 필요 시 파일 최상단에 추가
- className은 Tailwind만 사용
```

### 4. 효과적인 버그 수정 프롬프트
```
"다음 에러를 해결해줘:

에러 메시지: [정확한 에러 메시지 복사]
발생 위치: @components/UserProfile.tsx 25번째 줄
재현 방법: 로그인 후 프로필 페이지 접속
예상 동작: 사용자 정보가 표시되어야 함
실제 동작: 화면이 흰색으로 나옴

관련 파일: @hooks/useUser.ts @api/userService.ts"
```

### 5. 리팩토링 요청 시 구체적으로
```
❌ 모호한 요청:
"이 코드를 더 좋게 만들어줘"

✅ 구체적인 요청:
"@utils/dataProcessor.ts 파일을 다음 기준으로 리팩토링해줘:
1. 함수를 더 작은 단위로 분리
2. TypeScript 타입 안정성 강화
3. 에러 핸들링 개선
4. 성능 최적화 (특히 배열 처리 부분)
5. 단위 테스트도 함께 작성해줘"
```

## 🎨 UI/UX 작업 프롬프트 팁

### 1. 스크린샷 활용
이미지를 프롬프트에 포함하면 놀라울 정도로 정확한 결과를 얻을 수 있습니다.

```
[스크린샷 첨부]
"이 디자인과 똑같이 React 컴포넌트를 만들어줘. 
Tailwind CSS 사용하고, 반응형으로 만들어줘."
```

### 2. 디자인 시스템 참조
```
"@styles/design-system.css에 정의된 컬러팔레트와 
@components/Button.tsx의 스타일을 따라서 
Card 컴포넌트를 만들어줘"
```

## 🔧 디버깅과 문제 해결

### 1. 컨텍스트 윈도우 관리
- 긴 대화가 계속되면 컨텍스트가 손실됩니다
- 새로운 기능 작업 시 새 대화 시작
- 불필요한 파일 참조 제거

### 2. 모델 선택 가이드
```
Claude 3.5 Sonnet: 대부분의 코딩 작업 (기본 추천)
GPT-4: 복잡한 논리적 사고가 필요한 작업
o1-mini: 수학적 계산이나 복잡한 알고리즘
o1-preview: 매우 복잡한 문제 (비싸므로 신중히 사용)
```

### 3. 에러 발생 시 대처법
```
"지금 다음과 같은 문제가 발생했어:

1. 에러 메시지: [정확한 메시지]
2. 파일: [파일 경로와 라인 번호]
3. 기대한 결과: [구체적으로]
4. 실제 결과: [구체적으로]
5. 최근 변경사항: [변경한 내용들]

단계별로 디버깅해줘."
```

## 📚 문서 및 외부 리소스 활용

### 1. 라이브러리 문서 참조
```
"@docs/react-query.md 문서를 참고해서 
무한 스크롤 기능을 구현해줘. 
최신 v5 문법을 사용해야 해."
```

### 2. API 명세 활용
```
"@docs/api-specification.yaml을 참고해서 
TypeScript 타입 정의와 API 클라이언트를 생성해줘"
```

## 🎯 프롬프트 작성 체크리스트

### ✅ 좋은 프롬프트의 조건
- [ ] 구체적이고 명확한 요구사항
- [ ] 필요한 컨텍스트 파일 참조 (`@` 사용)
- [ ] 기술 스택과 제약사항 명시
- [ ] 예상 결과물 설명
- [ ] 테스트나 검증 방법 포함

### ❌ 피해야 할 프롬프트
- [ ] "좋게 만들어줘" 같은 모호한 표현
- [ ] 너무 많은 파일을 한 번에 참조
- [ ] 관련 없는 컨텍스트 포함
- [ ] 단계별 설명 없는 복잡한 요청

## 🚀 실전 프롬프트 템플릿

### 새 기능 개발
```
"[기능명]을 구현해줘.

요구사항:
- [구체적인 요구사항 1]
- [구체적인 요구사항 2]
- [구체적인 요구사항 3]

기술 스택: [사용할 기술들]
참고 파일: @[관련 파일들]

다음 순서로 진행해줘:
1. [단계 1]
2. [단계 2]
3. [단계 3]

테스트 코드도 함께 작성해줘."
```

### 버그 수정
```
"다음 버그를 수정해줘:

🐛 문제 상황:
- 에러: [에러 메시지]
- 위치: @[파일경로] [라인번호]
- 재현방법: [단계별 재현 방법]

🎯 기대결과:
[원하는 동작]

📁 관련 파일:
@[파일1] @[파일2] @[파일3]

우선 문제를 분석하고 해결 방안을 제시한 후 수정해줘."
```

### 리팩토링
```
"@[파일명]을 다음 기준으로 리팩토링해줘:

🎯 목표:
- [목표 1]
- [목표 2]
- [목표 3]

📋 체크리스트:
- [ ] 코드 가독성 향상
- [ ] 성능 최적화
- [ ] 타입 안정성 강화
- [ ] 테스트 코드 작성

기존 기능은 그대로 유지하면서 개선해줘."
```

이러한 팁들을 활용하면 Cursor와 훨씬 더 효과적으로 협업할 수 있습니다. 가장 중요한 것은 **구체적인 컨텍스트 제공**과 **명확한 요구사항 전달**입니다! 🎯